#!/usr/bin/env python3
"""Fetch ASN names from Cloudflare Radar API for ASNs seen in Loki logs.

Usage:
    # Port-forward Loki first, then:
    CLOUDFLARE_RADAR_API_TOKEN=xxx python3 fetch_asn_names.py

    # Custom Loki URL:
    CLOUDFLARE_RADAR_API_TOKEN=xxx LOKI_URL=http://loki:3100 python3 fetch_asn_names.py

Queries Loki for unique ClientASN values (last 7d), then resolves each
via the Cloudflare Radar single-ASN endpoint. Falls back to the ipverse
static CSV for any ASN that Radar can't resolve.

Creates/updates asn_names.py in the same directory.
"""
import csv
import io
import json
import os
import sys
import time
import urllib.error
import urllib.parse
import urllib.request

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ASN_NAMES_FILE = os.path.join(SCRIPT_DIR, "asn_names.py")
RADAR_TOKEN = os.environ.get("CLOUDFLARE_RADAR_API_TOKEN", "")
LOKI_URL = os.environ.get("LOKI_URL", "http://localhost:3100")
IPVERSE_CSV = "https://raw.githubusercontent.com/ipverse/asn-info/master/as.csv"


def load_existing():
    """Load existing ASN_NAMES dict if file exists."""
    if os.path.exists(ASN_NAMES_FILE):
        ns = {}
        exec(open(ASN_NAMES_FILE).read(), ns)
        return ns.get("ASN_NAMES", {})
    return {}


def query_loki_asns():
    """Query Loki for unique ClientASN values seen in the last 7 days."""
    query = (
        'count by (ClientASN) (count_over_time('
        '{job="cloudflare-logpush", dataset="http_requests"} '
        '| json ClientASN [7d]))'
    )
    params = urllib.parse.urlencode({"query": query, "time": str(int(time.time()))})
    url = f"{LOKI_URL}/loki/api/v1/query?{params}"
    req = urllib.request.Request(url)
    resp = urllib.request.urlopen(req, timeout=60)
    data = json.loads(resp.read())
    asns = set()
    for result in data.get("data", {}).get("result", []):
        asn = result.get("metric", {}).get("ClientASN", "")
        if asn and asn.isdigit():
            asns.add(int(asn))
    return sorted(asns)


def fetch_radar_asn(asn):
    """Fetch ASN name from Cloudflare Radar single-ASN endpoint."""
    url = f"https://api.cloudflare.com/client/v4/radar/entities/asns/{asn}?format=json"
    req = urllib.request.Request(url)
    req.add_header("Authorization", f"Bearer {RADAR_TOKEN}")
    try:
        resp = urllib.request.urlopen(req, timeout=10)
        data = json.loads(resp.read())
        if data.get("success"):
            info = data["result"]["asn"]
            # Prefer 'aka' (friendly name), fall back to 'name'
            return info.get("aka") or info.get("name") or None
    except urllib.error.HTTPError:
        pass
    except Exception:
        pass
    return None


def fetch_ipverse_csv():
    """Fetch static ASN names from ipverse as fallback."""
    data = urllib.request.urlopen(IPVERSE_CSV, timeout=15).read().decode("utf-8")
    reader = csv.reader(io.StringIO(data))
    next(reader)  # skip header
    return {int(row[0]): row[2] for row in reader}


def write_asn_names(mapping):
    """Write ASN_NAMES dict to asn_names.py."""
    lines = [
        "# ASN number to name mapping (only ASNs seen in Loki traffic)",
        "# Auto-generated by fetch_asn_names.py from Cloudflare Radar API",
        "# Fallback: ipverse/asn-info for ASNs not in Radar",
        "# Re-run to update: python3 fetch_asn_names.py",
        "ASN_NAMES = {",
    ]
    for asn in sorted(mapping.keys()):
        name = mapping[asn].replace('"', '\\"')
        lines.append(f'    {asn}: "{name}",')
    lines.append("}")
    with open(ASN_NAMES_FILE, "w") as f:
        f.write("\n".join(lines) + "\n")


def main():
    if not RADAR_TOKEN:
        print("Error: Set CLOUDFLARE_RADAR_API_TOKEN environment variable")
        print("Create a free API token at https://dash.cloudflare.com/profile/api-tokens")
        print("Required permission: Account > Account Analytics > Read")
        sys.exit(1)

    existing = load_existing()
    print(f"Existing ASN mappings: {len(existing)}")

    # Query Loki for ASNs
    print(f"Querying Loki at {LOKI_URL} for unique ASNs (last 7d)...")
    loki_asns = query_loki_asns()
    print(f"Found {len(loki_asns)} unique ASNs in Loki")

    # Determine which need resolving
    to_resolve = [asn for asn in loki_asns if asn not in existing]
    print(f"Already resolved: {len(loki_asns) - len(to_resolve)}, need resolving: {len(to_resolve)}")

    # Resolve via Radar single-ASN endpoint
    mapping = {asn: existing[asn] for asn in loki_asns if asn in existing}
    radar_failed = []

    if to_resolve:
        print(f"Resolving {len(to_resolve)} ASNs via Cloudflare Radar...")
        for i, asn in enumerate(to_resolve):
            name = fetch_radar_asn(asn)
            if name:
                # Clean up weird Radar names like "8068 8069" for Microsoft
                mapping[asn] = name
                print(f"  [{i+1}/{len(to_resolve)}] AS{asn} = {name}")
            else:
                radar_failed.append(asn)
                print(f"  [{i+1}/{len(to_resolve)}] AS{asn} = (Radar failed)")
            time.sleep(0.15)

    # Fallback to ipverse CSV for Radar failures
    if radar_failed:
        print(f"\nFalling back to ipverse CSV for {len(radar_failed)} ASNs...")
        csv_lookup = fetch_ipverse_csv()
        for asn in radar_failed:
            if asn in csv_lookup:
                mapping[asn] = csv_lookup[asn]
                print(f"  AS{asn} = {csv_lookup[asn]}")
            else:
                mapping[asn] = f"AS{asn}"
                print(f"  AS{asn} = (not found anywhere)")

    write_asn_names(mapping)
    named = sum(1 for n in mapping.values() if not (n.startswith("AS") and n[2:].isdigit()))
    print(f"\nWrote {len(mapping)} ASN mappings ({named} with names) to {ASN_NAMES_FILE}")


if __name__ == "__main__":
    main()
